// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
//    /home/ken/src/monad/util/ctypes/codegen/cg-ctypes -s
//    /home/ken/src/monad/libs/execution/ctypes rust -p monad-event-ring/src
//    -frustfmt +nightly

//! Definitions of event payloads used with the EXEC event ring

#![allow(non_camel_case_types)]
#![allow(unused_imports)]

use alloy_primitives::{Address, B256, U256};

use crate::eth_c_types::*;

/// Each type of event is assigned a unique value in this enumeration
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
#[repr(u16)]
pub enum exec_event_type {
    #[default]
    NONE,
    BLOCK_START,
    BLOCK_END,
    BLOCK_VOTED,
    BLOCK_FINALIZED,
    BLOCK_VERIFIED,
    BLOCK_REJECT,
    TXN_START,
    TXN_REJECT,
    TXN_LOG,
    TXN_RECEIPT,
    EVM_ERROR,
}

/// Stored in event ring's `ring_context` field to tag the block & transaction
/// context of event
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct flow_info {
    pub block_flow_id: u16, // Index into block flow metadata array
    pub txn_id: u32,        // txn id == txn_num + 1; id 0 -> no txn
}

/// Event recorded at the start of block execution
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_header {
    pub mch_hash: B256,                   // Monad consensus header hash
    pub round: u64,                       // Round of block proposal
    pub epoch: u64,                       // Epoch of block proposal
    pub parent_round: u64,                // Parent round of proposed block
    pub parent_mch_hash: B256,            // Consensus header hash of parent block
    pub consensus_seqno: u64,             // Proposal is for this block number
    pub parent_eth_hash: B256,            // Hash of Ethereum parent block
    pub chain_id: U256,                   // Block chain we're associated with
    pub exec_input: eth_block_exec_input, // Ethereum execution inputs
}

/// Event recorded upon successful transaction execution
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_result {
    pub eth_block_hash: B256,               // Hash of Ethereum block
    pub exec_output: eth_block_exec_output, // Ethereum execution outputs
}

/// Event recorded when a proposed block obtains a quorum certificate
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_voted {
    pub mch_hash: B256,        // Identity of voted block
    pub round: u64,            // Round when voted block was proposed
    pub epoch: u64,            // Epoch when voted block was proposed
    pub consensus_seqno: u64,  // Block number of voted block
    pub parent_mch_hash: B256, // Identity of parent block
    pub parent_round: u64,     // Round of parent block's proposal
}

/// Event recorded when consensus finalizes a block
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_finalized {
    pub mch_hash: B256,       // Id of finalized block
    pub round: u64,           // Round when finalized block was proposed
    pub consensus_seqno: u64, // Number of finalized block
}

/// Event recorded when consensus verifies the state root of a finalized block
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_verified {
    pub consensus_seqno: u64, // Number of verified block
}

/// Event recorded when a block is rejected (i.e., is invalid)
///
/// This corresponds to a value in the `BlockError` enumeration in
/// `validate_block.hpp`, in the execution repo source code.
pub type block_reject = u32;

/// Event recorded when transaction processing starts
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_start {
    pub txn_hash: B256,             // Keccak hash of transaction RLP
    pub sender: Address,            // Recovered sender address
    pub txn_header: eth_txn_header, // Transaction header
}

/// Event recorded when a transaction is rejected (i.e., is invalid)
///
/// This corresponds to a value in the `TransactionError` enumeration in
/// `validate_transaction.hpp`, in the execution repo source code.
pub type txn_reject = u32;

/// Event recorded when a transaction emits a LOG
pub type txn_log = eth_txn_log;

/// Event recorded when transaction execution halts
pub type txn_receipt = eth_txn_receipt;

/// Error occurred in execution process (not a validation error)
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct evm_error {
    pub domain_id: u64,   // Boost.Outcome domain id of error
    pub status_code: i64, // Boost.Outcome status code of error
}

pub fn format_as(bytes: &[u8], event_type: exec_event_type) -> String {
    match event_type {
        exec_event_type::NONE => String::from("NONE"),
        exec_event_type::BLOCK_START => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_header) })
        }
        exec_event_type::BLOCK_END => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_result) })
        }
        exec_event_type::BLOCK_VOTED => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_voted) })
        }
        exec_event_type::BLOCK_FINALIZED => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const block_finalized)
        }),
        exec_event_type::BLOCK_VERIFIED => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const block_verified)
        }),
        exec_event_type::BLOCK_REJECT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_reject) })
        }
        exec_event_type::TXN_START => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_start) })
        }
        exec_event_type::TXN_REJECT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_reject) })
        }
        exec_event_type::TXN_LOG => format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_log) }),
        exec_event_type::TXN_RECEIPT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_receipt) })
        }
        exec_event_type::EVM_ERROR => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const evm_error) })
        }
    }
}
