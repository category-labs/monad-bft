#!/usr/bin/env bash
set -Eeuo pipefail
trap 'ec=$?; echo 1>&2 "INTERNAL ERROR: ec=$ec line=$LINENO cmd=$BASH_COMMAND";
    exit $ec;' ERR

####################################################################
#   Test framework support functions

die() {
    local exitcode=$1; shift
    echo 1>&2 "$(basename "$0"):" "$@"
    exit $exitcode
}

#   Commands running tests that are expected to fail if something's wrong
#   in code under test should be tested with `… || fail "message"`.
#   Otherwise the failure will be indicated as an internal error in the
#   test framework.
fail() {
    echo 1>&2 "FAILURE:" "$@"
    exit 1
}

setup_docker() {
    declare -g docker=docker
    if ! $docker --version >/dev/null; then
        die 1 "Cannot run '$docker' command. Check path?"
    elif ! $docker info >/dev/null 2>&1; then
        docker='sudo docker'
        sudo -v -p 'sudo pw for %u@%h to run docker: ' \
            || die 3 "Cannot sudo to run '$docker'; start proxy?"
    fi
}

####################################################################
#   Build and test functions

build_package() {
    declare -g PROJDIR
    local tag=monad

    echo "----- Building image $tag"
    #   This is not really optimal; we have over 150,000 files under
    #   $PROJDIR and we include almost all 10 GB of them (even .git/
    #   subdirs) in the the build context, except for some excluded
    #   by a somewhat complex .dockerignore. (This takes about 30s per
    #   run.) This also can tend towards much more rebuilding than
    #   necessary unless care is taken with layer creation in the
    #   Dockerfile.
    $docker buildx build ${clean_big:+--no-cache=true} $quiet \
        ${clean_big:+--no-cache=true} $quiet ${loud:+--progress=plain} \
        --tag "$tag" -f "$PROJDIR"/package/Dockerfile "$PROJDIR"
}

####################################################################
#   Setup and Argument Parsing

export PROJDIR=$(command cd -P "$(dirname "$0")" && pwd)

#   The full set of tests, as we add them here, will take quite some time
#   to run, so as we go we need to add arguments to run subsets of the
#   tests. This will include things such as:
#   • Just unit tests, including options to select subsets of the unit tests.
#   • Build and smoke test of the package.

clean_big=
quiet=-q
loud=
while [[ ${#@} -gt 0 ]]; do case "$1" in
    -C)     shift; clean_big=true; rm -rf ".build/";;
    -v)     shift; quiet='';;
    -V)     shift; quiet=''; loud=true;;    # very verbose output
    --)     shift; break;;                  # allow options for subset tests
    *)      break;;
esac; done
[[ $# -eq 0 ]] || die 2 "Invalid arg: $1"

setup_docker

####################################################################
#   Main

build_package || fail build_package     # XXX resulting package not yet tested

echo OK.
